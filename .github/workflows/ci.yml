name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

concurrency:
  group: ci-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

jobs:
  ci:
    name: Lint → Test → Build
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Scan for leaked secrets
        if: github.event_name == 'pull_request'
        run: |
          pip install detect-secrets==1.5.0
          export PYTHONPATH=.

          # Fresh scan → compare against committed baseline
          detect-secrets scan \
            --exclude-files '(^|/)(package-lock\.json$|dist/|\.next/|node_modules/|\.detect-secrets\.cfg$|\.secrets\.baseline$)' \
            > /tmp/new-baseline.json

          python3 - <<'PYEOF'
          import json, sys
          old = json.load(open(".secrets.baseline"))
          new = json.load(open("/tmp/new-baseline.json"))
          old_set = {(f, s["line_number"], s["hashed_secret"])
                     for f, secrets in old.get("results", {}).items() for s in secrets}
          new_set = {(f, s["line_number"], s["hashed_secret"])
                     for f, secrets in new.get("results", {}).items() for s in secrets}
          added = new_set - old_set
          if added:
              print(f"::error::{len(added)} new potential secret(s) detected:")
              for f, line, _ in sorted(added):
                  print(f"  {f}:{line}")
              print("\nRun locally: detect-secrets scan > .secrets.baseline && detect-secrets audit .secrets.baseline")
              sys.exit(1)
          print("No new secrets detected.")
          PYEOF

      - name: Check for sensitive files
        if: github.event_name == 'pull_request'
        run: |
          SENSITIVE=(
            '\.env$'
            '\.env\.'
            '\.pem$'
            '\.key$'
            '\.p12$'
            '\.pfx$'
            '\.jks$'
            'id_rsa'
            'id_ed25519'
            'id_ecdsa'
            '\.castle/'
            '\.openclaw/'
            'castle\.json$'
            'device\.json$'
            'credentials\.json$'
            '\.npmrc$'
            '\.yarnrc$'
            'castle\.db'
            'castle-[0-9].*\.db'
            'backups/'
            '\.db-wal$'
            '\.db-shm$'
            '\.sqlite$'
            '\.sqlite3$'
            '\.sql$'
            '\.log$'
            '\.err$'
          )

          NEW_FILES=$(git diff --name-only --diff-filter=A origin/main...HEAD)
          FOUND=0
          for PATTERN in "${SENSITIVE[@]}"; do
            MATCHES=$(echo "$NEW_FILES" | grep -P "$PATTERN" || true)
            if [ -n "$MATCHES" ]; then
              echo "::error::Sensitive file added: $MATCHES"
              FOUND=1
            fi
          done

          if [ "$FOUND" -eq 1 ]; then
            echo "::error::Sensitive files detected. Add them to .gitignore and remove from the PR."
            exit 1
          fi
          echo "No sensitive files detected."

      - name: Check for large files
        if: github.event_name == 'pull_request'
        run: |
          MAX_KB=512
          LARGE=$(git diff --name-only --diff-filter=d origin/main...HEAD | while read -r f; do
            if [ -f "$f" ]; then
              SIZE=$(wc -c < "$f")
              if [ "$SIZE" -gt $((MAX_KB * 1024)) ]; then
                echo "$f ($(( SIZE / 1024 ))KB)"
              fi
            fi
          done)

          if [ -n "$LARGE" ]; then
            echo "::error::Files over ${MAX_KB}KB detected (excluding package-lock.json):"
            echo "$LARGE" | grep -v 'package-lock.json' || true
            FILTERED=$(echo "$LARGE" | grep -v 'package-lock.json' || true)
            if [ -n "$FILTERED" ]; then
              echo "::error::Large files should not be committed to git. Use .gitignore or Git LFS."
              exit 1
            fi
          fi
          echo "No oversized files detected."

      - name: Check for stray console.log in source
        if: github.event_name == 'pull_request'
        run: |
          DIFF=$(git diff origin/main...HEAD -- 'src/' ':!src/**/__tests__/**' ':!src/**/*.test.*')

          # Allow structured dev logs like console.log("[Tag]...") and console.log(`[Tag]...`)
          # Only flag bare console.log() calls without a bracketed prefix
          MATCHES=$(echo "$DIFF" \
            | grep -n '^\+.*console\.log' \
            | grep -v '^\+.*//.*console\.log' \
            | grep -v 'console\.log(`\[' \
            | grep -v 'console\.log("\[' \
            | grep -v "console\.log('\[" \
            | grep -v 'console\.log(\s*$' \
            || true)

          if [ -n "$MATCHES" ]; then
            echo "::warning::Unstructured console.log statements found in source code (not tests):"
            echo "$MATCHES"
            echo ""
            echo "::error::Use structured logging with a prefix: console.log('[Tag] message')"
            exit 1
          fi
          echo "No stray console.log found."

      - name: Audit GitHub Actions workflows
        if: github.event_name == 'pull_request'
        run: |
          pip install zizmor
          zizmor --config zizmor.yml .github/workflows/

      - name: Check version bump and changelog
        if: github.event_name == 'pull_request'
        run: |
          # Skip checks if only CI/docs/config files changed
          CHANGED=$(git diff --name-only origin/main...HEAD)
          CODE_CHANGED=$(echo "$CHANGED" | grep -v '^\.github/' | grep -v '^LICENSE' | grep -v '^CONTRIBUTING\.md' | grep -v '^SECURITY\.md' | grep -v '^CHANGELOG\.md' | grep -v '^\.gitattributes$' | grep -v '^\.gitignore$' | grep -v '^\.detect-secrets' | grep -v '^\.pre-commit' | grep -v '^\.secrets\.baseline$' | grep -v '^zizmor\.yml$' | grep -v '^castle_secrets\.py$' | grep -v '^\.github/.*\.md$' || true)

          if [ -z "$CODE_CHANGED" ]; then
            echo "Only CI/docs files changed — skipping version bump and changelog checks."
            exit 0
          fi

          # Check CHANGELOG.md was updated
          if ! echo "$CHANGED" | grep -q '^CHANGELOG\.md$'; then
            echo "::error::CHANGELOG.md has not been updated. Please add an entry for this release."
            exit 1
          fi

          MAIN_VERSION=$(git show origin/main:package.json | node -e "process.stdin.setEncoding('utf8');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>console.log(JSON.parse(d).version))")
          PR_VERSION=$(node -p "require('./package.json').version")
          echo "main: $MAIN_VERSION → PR: $PR_VERSION"
          if [ "$MAIN_VERSION" = "$PR_VERSION" ]; then
            echo "::error::Version in package.json ($PR_VERSION) has not been bumped from main. Please update the version before merging."
            exit 1
          fi

      - name: Install dependencies
        run: npm ci

      - name: Audit dependencies
        run: npm audit --omit=dev --audit-level=high

      - name: Test
        run: npm test

      - name: Build
        run: npm run build

  release:
    name: Tag & Publish
    needs: ci
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: write
      id-token: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: https://registry.npmjs.org

      - name: Upgrade npm for trusted publishing
        run: npm install -g npm@latest

      - name: Create version tag
        run: |
          VERSION="v$(node -p "require('./package.json').version")"
          if git ls-remote --tags origin "$VERSION" | grep -q "$VERSION"; then
            echo "Tag $VERSION already exists, skipping."
          else
            git tag "$VERSION"
            git push origin "$VERSION"
            echo "Tagged $VERSION"
          fi

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Publish to npm
        run: |
          VERSION=$(node -p "require('./package.json').version")
          PUBLISHED=$(npm view @castlekit/castle version 2>/dev/null || echo "none")
          if [ "$VERSION" = "$PUBLISHED" ]; then
            echo "v$VERSION already published, skipping."
          else
            npm publish --access public --provenance
            echo "Published @castlekit/castle@$VERSION"
          fi
