name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

concurrency:
  group: ci-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

jobs:
  ci:
    name: Lint → Test → Build
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Scan for leaked secrets
        if: github.event_name == 'pull_request'
        run: |
          pip install detect-secrets==1.5.0
          # PYTHONPATH loads the Castle/OpenClaw custom detector plugin
          export PYTHONPATH=.detect-secrets-plugins
          detect-secrets scan \
            --baseline .secrets.baseline \
            --exclude-files '(^|/)(package-lock\.json$|dist/|\.next/|node_modules/|\.detect-secrets\.cfg$|\.secrets\.baseline$)'
          detect-secrets audit --report --baseline .secrets.baseline

      - name: Check for sensitive files
        if: github.event_name == 'pull_request'
        run: |
          SENSITIVE=(
            '\.env$'
            '\.env\.'
            '\.pem$'
            '\.key$'
            '\.p12$'
            '\.pfx$'
            '\.jks$'
            'id_rsa'
            'id_ed25519'
            'id_ecdsa'
            '\.castle/'
            '\.openclaw/'
            'castle\.json$'
            'device\.json$'
            'credentials\.json$'
            '\.npmrc$'
            '\.yarnrc$'
            'castle\.db'
            'castle-[0-9].*\.db'
            'backups/'
            '\.db-wal$'
            '\.db-shm$'
            '\.sqlite$'
            '\.sqlite3$'
            '\.sql$'
            '\.log$'
            '\.err$'
          )

          NEW_FILES=$(git diff --name-only --diff-filter=A origin/main...HEAD)
          FOUND=0
          for PATTERN in "${SENSITIVE[@]}"; do
            MATCHES=$(echo "$NEW_FILES" | grep -P "$PATTERN" || true)
            if [ -n "$MATCHES" ]; then
              echo "::error::Sensitive file added: $MATCHES"
              FOUND=1
            fi
          done

          if [ "$FOUND" -eq 1 ]; then
            echo "::error::Sensitive files detected. Add them to .gitignore and remove from the PR."
            exit 1
          fi
          echo "No sensitive files detected."

      - name: Check for large files
        if: github.event_name == 'pull_request'
        run: |
          MAX_KB=512
          LARGE=$(git diff --name-only --diff-filter=d origin/main...HEAD | while read -r f; do
            if [ -f "$f" ]; then
              SIZE=$(wc -c < "$f")
              if [ "$SIZE" -gt $((MAX_KB * 1024)) ]; then
                echo "$f ($(( SIZE / 1024 ))KB)"
              fi
            fi
          done)

          if [ -n "$LARGE" ]; then
            echo "::error::Files over ${MAX_KB}KB detected (excluding package-lock.json):"
            echo "$LARGE" | grep -v 'package-lock.json' || true
            FILTERED=$(echo "$LARGE" | grep -v 'package-lock.json' || true)
            if [ -n "$FILTERED" ]; then
              echo "::error::Large files should not be committed to git. Use .gitignore or Git LFS."
              exit 1
            fi
          fi
          echo "No oversized files detected."

      - name: Check for stray console.log in source
        if: github.event_name == 'pull_request'
        run: |
          DIFF=$(git diff origin/main...HEAD -- 'src/' ':!src/**/__tests__/**' ':!src/**/*.test.*')

          # Allow structured dev logs like console.log("[Tag]...") and console.log(`[Tag]...`)
          # Only flag bare console.log() calls without a bracketed prefix
          MATCHES=$(echo "$DIFF" \
            | grep -n '^\+.*console\.log' \
            | grep -v '^\+.*//.*console\.log' \
            | grep -v 'console\.log(`\[' \
            | grep -v 'console\.log("\[' \
            | grep -v "console\.log('\[" \
            | grep -v 'console\.log(\s*$' \
            || true)

          if [ -n "$MATCHES" ]; then
            echo "::warning::Unstructured console.log statements found in source code (not tests):"
            echo "$MATCHES"
            echo ""
            echo "::error::Use structured logging with a prefix: console.log('[Tag] message')"
            exit 1
          fi
          echo "No stray console.log found."

      - name: Audit GitHub Actions workflows
        if: github.event_name == 'pull_request'
        run: |
          pip install zizmor
          zizmor --config zizmor.yml .github/workflows/

      - name: Check version bump
        if: github.event_name == 'pull_request'
        run: |
          # Skip version bump check if only CI/docs/config files changed
          CHANGED=$(git diff --name-only origin/main...HEAD)
          CODE_CHANGED=$(echo "$CHANGED" | grep -v '^\.github/' | grep -v '^LICENSE' | grep -v '^CONTRIBUTING\.md' | grep -v '^SECURITY\.md' | grep -v '^CHANGELOG\.md' | grep -v '^\.gitattributes$' | grep -v '^\.detect-secrets' | grep -v '^\.pre-commit' | grep -v '^\.secrets\.baseline$' | grep -v '^zizmor\.yml$' | grep -v '^\.github/.*\.md$' || true)

          if [ -z "$CODE_CHANGED" ]; then
            echo "Only CI/docs files changed — skipping version bump check."
            exit 0
          fi

          MAIN_VERSION=$(git show origin/main:package.json | node -e "process.stdin.setEncoding('utf8');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>console.log(JSON.parse(d).version))")
          PR_VERSION=$(node -p "require('./package.json').version")
          echo "main: $MAIN_VERSION → PR: $PR_VERSION"
          if [ "$MAIN_VERSION" = "$PR_VERSION" ]; then
            echo "::error::Version in package.json ($PR_VERSION) has not been bumped from main. Please update the version before merging."
            exit 1
          fi

      - name: Install dependencies
        run: npm ci

      - name: Audit dependencies
        run: npm audit --omit=dev --audit-level=high

      - name: Test
        run: npm test

      - name: Build
        run: npm run build

  release:
    name: Tag & Publish
    needs: ci
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: write
      id-token: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: https://registry.npmjs.org

      - name: Upgrade npm for trusted publishing
        run: npm install -g npm@latest

      - name: Create version tag
        run: |
          VERSION="v$(node -p "require('./package.json').version")"
          if git ls-remote --tags origin "$VERSION" | grep -q "$VERSION"; then
            echo "Tag $VERSION already exists, skipping."
          else
            git tag "$VERSION"
            git push origin "$VERSION"
            echo "Tagged $VERSION"
          fi

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Publish to npm
        run: |
          VERSION=$(node -p "require('./package.json').version")
          PUBLISHED=$(npm view @castlekit/castle version 2>/dev/null || echo "none")
          if [ "$VERSION" = "$PUBLISHED" ]; then
            echo "v$VERSION already published, skipping."
          else
            npm publish --access public --provenance
            echo "Published @castlekit/castle@$VERSION"
          fi

      - name: Update changelog
        run: |
          # Auto-generate CHANGELOG.md from git tags and commit messages
          cat > CHANGELOG.md << 'HEADER'
          # Changelog

          All notable changes to Castle are documented here.
          This file is auto-generated from git history on each release.

          HEADER

          # Trim leading whitespace from heredoc
          sed -i 's/^          //' CHANGELOG.md

          TAGS=$(git tag --sort=-version:refname)
          PREV=""
          for TAG in $TAGS; do
            DATE=$(git log -1 --format='%as' "$TAG")
            VERSION="${TAG#v}"
            echo "" >> CHANGELOG.md
            echo "## $VERSION ($DATE)" >> CHANGELOG.md

            if [ -n "$PREV" ]; then
              RANGE="$TAG..$PREV"
            else
              # Most recent tag — include commits from tag to HEAD
              RANGE="$TAG..HEAD"
            fi
            PREV="$TAG"

            # Categorize commits
            ADDED=""
            FIXED=""
            CHANGED=""

            while IFS= read -r line; do
              msg="${line#* }"
              case "$msg" in
                Add*|Implement*|"Full "*|"Chat V1"*|"Phase 1"*|"Universal Search"*)
                  ADDED="$ADDED\n- $msg" ;;
                Fix*|"FTS5 "*|Recover*)
                  FIXED="$FIXED\n- $msg" ;;
                Bump*|Merge*) ;;
                *)
                  CHANGED="$CHANGED\n- $msg" ;;
              esac
            done <<< "$(git log --oneline "$RANGE" 2>/dev/null || git log --oneline "$TAG")"

            if [ -n "$ADDED" ]; then
              echo "" >> CHANGELOG.md
              echo "### Added" >> CHANGELOG.md
              echo -e "$ADDED" >> CHANGELOG.md
            fi
            if [ -n "$FIXED" ]; then
              echo "" >> CHANGELOG.md
              echo "### Fixed" >> CHANGELOG.md
              echo -e "$FIXED" >> CHANGELOG.md
            fi
            if [ -n "$CHANGED" ]; then
              echo "" >> CHANGELOG.md
              echo "### Changed" >> CHANGELOG.md
              echo -e "$CHANGED" >> CHANGELOG.md
            fi
          done

          # Commit updated changelog back to main
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          if git diff --cached --quiet; then
            echo "No changelog changes to commit."
          else
            git commit -m "docs: update CHANGELOG.md [skip ci]"
            git push origin main
          fi
